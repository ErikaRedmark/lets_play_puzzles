# Pentomino: For each of the 12 pentominoes, of which are
# 2 F's, one in each reflection
# 1 L in standard form
# 3 N's, 2 of which are in standard form, 1 is flipped
# 1 P in standard form
# 1 T
# 1 U
# 1 V
# 1 W
# 1 Z, flipped
# Square: 60 squares. Must be covered by a pentomino exactly once.
#   Any more and it means things are overlapping.
# Total of 72 (12 pentiominoes and 60 squares) constraints.
#
# Incidence Matrix: One row for each subset of S and column for each
#   element in X
# S = Board
# X = Pentonmino
# The matrix is generated by another program, which generates the following
# structure:
# - List of pieces (Tuple of Name and Positions)
# |--- List of all valid positions
# |------ Position (A list of tuples, first element is ith row and second
#         is jth column)
#

# infinite_check = []
from copy import deepcopy


def solve(all_pieces):
    """Solves the pentomino packing problem.
    One of each piece in valid_positions is placed on the board using one
    of the provided positions such that no two pieces overlap at any point.
    This does NOT check if there are empty squares, because if every piece
    is placed without overlap, there shouldn't be any empty squares.
    Returns a list of pieces and positions (tuple of piece name and a list
    itself containing 5 tuples indicating square positions of the piece),
    or none if there are no solutions.
    Algorithm ends when it has exhausted every possible solution. Due to
    this, it is recommend to trim the all_pieces matrix such that positions
    that already obviously cause unwinnable scenarios are simply not present"""

    solutions = []
    internal_solve([], all_pieces, [], solutions)
    return solutions


def internal_solve(current_board, remaining_pieces, placed_pieces,
        solution_accumulator):
    """Attempts to place one piece, then calls itself for the remaining.
    If it cannot place the piece, returns null to signify no solution.
    Otherwise, will return the location it placed the piece appended
    to the list of locations all future pieces were added to. This
    recursion stops when a piece is placed, and no remaining pieces remain.

    -- current_board: list of tuples indicating positions already taken up
        by 'some' piece.
    -- piece_name: the name of the piece being placed here. Intended to
        allow the returned solutions to address it by name.
    -- positions: a list of valid positions the piece can go on the given
        board. These valid positions indicate places it could fit anywhere
        on the board without regard to other piece placements. Typically,
        this list is autogenerated and few to this algorithm.
    -- remaining_pieces: the list of all pieces still yet to be placed, and
        all their valid positions they could be placed in. When internal_solve
        is called within, the current piece and positions are removed from
        this list after being placed. Recursion ends when the last piece is
        placed and this is therefore empty."""
    piece_name, positions = remaining_pieces[0]
    new_remaining = remaining_pieces[1:]

    for position in positions:
        if (check_valid(current_board, position)):
            new_board = list(current_board)
            for coord in position:
                new_board.append(coord)

            # if ((piece_name, position, current_board) in infinite_check):
            #     raise RuntimeError("Already attempted to place {0} at {1}".
            #         format(piece_name, position))
            # infinite_check.append((piece_name, position, current_board))
            # print("placed {0} at {1}".format(piece_name, position))

            if (len(new_remaining) == 0):
                return (piece_name, position)

            placed_pieces_new = placed_pieces + [(piece_name, position)]
            result = internal_solve(new_board, new_remaining,
                placed_pieces_new, solution_accumulator)

            # A solution was found.
            if (result is not None):
                solution_accumulator.append(placed_pieces_new + [result])

    # gone through all positions; nothing more to do at this depth.
    return None


def check_valid(current_board, position):
    """checks if the current board (list of taken up i, j squares) can taken
    a piece at the given position."""
    for coord in position:
        if (coord in current_board):
            return False
    return True
